#  ScotPHO indicators: 2 indicator outputs from this script 
#  Female measures of life Expectancy inequality ,
#  Male measures of life expectancy inequality ,

# Inequalities measures for life expectancy require life expectancy data by SIMD quintile (generated by NRS) using equivalent time periods (eg 5 year average)
# Robust life expectancy estimate generation require sufficient data by individual year ages and sex and SIMD quintile this requires 5 years of data rather 
# than single year or 3 years data that is used in the main life expectancy profiles indicators

# Geographies available Scotland (Scotland Quintile), Council Area (using within Council SIMD quintile) and Health Board (within HB SIMD quinilte) 
# Within Scotland SIMD quintile estimates not available at CA or HB level as NRS do no routinely generate this data and unsure if the life expectancies would be robust given likely many categories where cells would be small/zeros

#   Part 1 - Import & manipulate raw data files provided by NRS.
#   Part 2 - Run analysis functions 

###############################################.
## Packages/Filepaths/Functions ----
###############################################.

#source("1.indicator_analysis.R") #Normal indicator functions
source("2.deprivation_analysis.R") # deprivation function

# Extracts for Life Expectancy data saved in left expectancy network folder.
if (sessionInfo()$platform %in% c("x86_64-redhat-linux-gnu (64-bit)", "x86_64-pc-linux-gnu (64-bit)")) {
  source_network <- "/PHI_conf/ScotPHO/Life Expectancy/Data/Source Data/NRS data/"
} else {
  source_network <- "//stats/ScotPHO/Life Expectancy/Data/Source Data/NRS data/"
}

###############################################.
#   Small function to save final output files ----
###############################################.

save_output<-function(filename) {
  saveRDS(data_depr, paste0(data_folder, "Temporary/", filename, "_final.rds")) # not sure i really need this stage
  
  #Preparing data for Shiny tool
  data_shiny <- data_depr %>% 
    select(-c(most_rate, least_rate))
  
  #Saving file
  saveRDS(data_shiny, file = paste0(data_folder, "Data to be checked/", filename, "_ineq.rds"))
}




###############################################.
#   Part 1 - Import & manipulate raw data files provided by NRS. ----
###############################################.


#example of file end fields and structure 
example_ineq <- read_rds("/PHI_conf/ScotPHO/Profiles/Data/Shiny Data/deaths_allages_depr_ineq.rds")

# Mannually created Lookup for adding area standard geography codes to geography names.
area_lookup <- read_excel("/PHI_conf/ScotPHO/Life Expectancy/Data/Source Data/Area Lookup.xlsx")

# Open Health Board LE data
hb_depr_data <- read_excel(paste0(source_network,"life expectancy in health boards split by SIMD 2013-2017 to 2016-2020.xlsx")) %>%
  setNames(tolower(names(.))) %>%  #variables to lower case
  mutate(quint_type=case_when(substr(area,1,4) != "Scot" ~ "hb_quin",substr(area,1,4) == "Scot" ~"sc_quin")) #add field labelling quintile type - within HB quintile

# Open Health Board LE data (remove Scotland level data as already avialable in HB level data extract)
ca_depr_data <- read_excel(paste0(source_network,"life expectancy in council areas split by SIMD 2013-2017 to 2016-2020.xlsx")) %>%
  setNames(tolower(names(.))) %>% #variables to lower case
  subset(substr(area,1,4) != "Scot") %>% #remove scotland data from one dataset (already present in HB file)
  mutate(quint_type="ca_quin")


# Bind HB and CA data & rename fields
data_depr <- bind_rows(hb_depr_data,ca_depr_data) %>%
  filter(age_band=="less than 1") %>%
  rename(lowci= lower_le, upci=upper_le,rate=ex, denominator=populations, trend_axis=period) %>%
  mutate(quintile = substr(area, nchar(area)-1+1, nchar(area)),
         quintile = case_when(quintile=="0" ~ "Total", TRUE ~ quintile),
         area=substr(area,start=1,stop = nchar(area)-1),
         year=as.numeric(substr(trend_axis,1,4))+2) %>% #year field set to mid-point of time series - used in charting
  select(-lx,-age_band, -deaths)

#match on geography Standard geography codes
data_depr <- left_join(data_depr, area_lookup, by = c("area"))


rm(area_lookup,hb_depr_data,ca_depr_data)



##################################################.
##  Part 2 - Call deprivation analysis functions ----
##################################################.

##Female Life expectancy

data_depr <-data_depr %>%
  filter(sex=="F")

#call function to generate measures of inequality
inequality_measures()

#edit fields to match those required by profiles tool
data_depr <- data_depr %>%
  select(year, code, quintile, quint_type, denominator, rate, lowci,upci,sii:rel_range,trend_axis) %>%
  mutate(ind_id=9999,
         numerator = 0,
     def_period = paste0(trend_axis,"; ","5 year period life expectancy")) %>%
  # fill in missing values and if any have negative lower CI change that to zero.
  mutate_at(c("rate", "lowci", "upci"), ~replace(., is.na(.), 0)) 
 data_depr$lowci <- ifelse(data_depr$lowci<0, 0, data_depr$lowci)

 save_output(filename="life_expectancy_inequalities_female")


#add indicator ID
#add def period
#add empty numerator column - le doesn't have


##################################################.
##  Part 2 - Create SII and RII ----
##################################################.
#Splitting into two files: one with quintiles for SII and one without to keep the total values
#file 1 : quintile level data
data_depr_sii  <- data_depr %>% group_by(code, period, quint_type) %>% 
  mutate(overall_le = le[quintile == "0"]) %>% 
  filter(quintile != "0") %>% 
  #This variables are used for SII, RII and PAR calculation
  mutate(total_pop = sum(pop), # calculate the total population for each area (without SIMD).
         proportion_pop = pop/total_pop) %>% # proportion of the population in each SIMD out of the total population. )
  ungroup()

#file 2 : total data
data_depr_totals <- data_le_dep_female %>% filter(quintile == "0")





# ####Charting checks ----
# 
# data_depr_sii_chart <- data_depr_sii %>%
#   filter(area=="Scotland")
# 
# p <- plot_ly(data=data_depr_sii_chart , x=~quintile) %>%
#   #Comparator line
#   add_trace(y = ~le, name = "Le", type = 'scatter', mode = 'lines',
#             line = list(color = '#FF0000'), hoverinfo="skip") %>% 
#   layout(bargap = 0.1, margin=list(b = 140), #to avoid labels getting cut out
#          showlegend = FALSE) %>%
#   config(displayModeBar = F, displaylogo = F, editable =F) # taking out toolbar
# 
# p
# 
# #Creating plot
# p_line <- plot_ly(data=data_depr_sii_chart, x=~year, 
#                   text=~quintile, textposition="none", hoverinfo="text") %>%
#   add_lines(y = ~le, name = "", type = 'scatter', 
#             mode = 'lines', color = ~quintile) 
# 
# p_line

####Charting checks 

###############################################.
# Calculate the regression coefficient
#Formula from: https://www.scotpho.org.uk/comparative-health/health-inequalities-tools/archive/triple-i-and-hits/
#https://pdfs.semanticscholar.org/14e0/c5ba25a4fdc87953771a91ec2f7214b2f00d.pdf
#The dataframe sii_model will have a column for sii, lower ci and upper ci for each
# geography, year and quintile type
sii_model <- data_depr_sii %>% group_by(code, year, quint_type) %>% 
  #Checking that all quintiles are present, if not excluding as we are not showing
  #RII and SII for those. Calculations would need to be adjusted and thought well if we wanted to include them
  mutate(count= n()) %>% filter(count == 5) %>% 
  #This first part is to adjust rate and denominator with the population weights
  mutate(cumulative_pro = cumsum(proportion_pop),  # cumulative proportion population for each area
         relative_rank = case_when(
           quintile == "1" ~ 0.5*proportion_pop,
           quintile != "1" ~ lag(cumulative_pro) + 0.5*proportion_pop),
         sqr_proportion_pop = sqrt(proportion_pop), #square root of the proportion of the population in each SIMD
         relrank_sqr_proppop = relative_rank * sqr_proportion_pop,
         rate_sqr_proppop = sqr_proportion_pop * le) %>% #rate based on population weights
  nest() %>% #creating one column called data with all the variables not in the grouping
  # Calculating linear regression for all the groups, then formatting the results
  # and calculating the confidence intervals
  mutate(model = map(data, ~ lm(rate_sqr_proppop ~ sqr_proportion_pop + relrank_sqr_proppop + 0, data = .)),
         #extracting sii from model, a bit fiddly but it works
         sii = -1 * as.numeric(map(map(model, "coefficients"), "relrank_sqr_proppop")),
         cis = map(model, confint_tidy)) %>% #calculating confidence intervals
  ungroup() %>% unnest(cis) %>% #Unnesting the CIs 
  #selecting only even row numbers which are the ones that have the sii cis
  filter(row_number() %% 2 == 0) %>% 
  mutate(lowci_sii = -1 * conf.high, #fixing interpretation
         upci_sii = -1 * conf.low) %>% 
  select(-conf.low, -conf.high, -model, -data) %>% #taking out results as not needed anymore
  mutate_at(c("sii", "lowci_sii", "upci_sii"), ~replace(., is.na(.), NA_real_)) #recoding NAs

#Merging sii with main data set
data_depr <- left_join(data_depr_sii, sii_model, by = c("code", "year", "quint_type"))

#Calculating RII
data_depr <- data_depr %>% mutate(rii = sii / overall_le,
                                  lowci_rii = lowci_sii / overall_le,
                                  upci_rii = upci_sii / overall_le,
                                  #Transforming RII into %. This way is interpreted as "most deprived areas are
                                  # xx% above the average" For example: Cancer mortality rate is around 55% higher 
                                  # in deprived areas relative to the mean rate in the population
                                  rii_int = rii * 0.5 *100,
                                  lowci_rii_int = lowci_rii * 0.5 *100,
                                  upci_rii_int = upci_rii * 0.5 *100)





##################################################.
##  Part 7 - Population attributable risk and range  ----
##################################################.
#Calculation PAR
#Formula here: https://pdfs.semanticscholar.org/14e0/c5ba25a4fdc87953771a91ec2f7214b2f00d.pdf
# https://fhop.ucsf.edu/sites/fhop.ucsf.edu/files/wysiwyg/pg_apxIIIB.pdf
#Adding columns for Most and least deprived rates
most_depr <- data_depr %>% filter(quintile == "1") %>% 
  select(code, year, quint_type, le) %>% rename(most_rate = le)

least_depr <- data_depr %>% filter(quintile == "5") %>% 
  select(code, year, quint_type, le) %>% rename(least_rate = le)

data_depr <- left_join(data_depr, most_depr, by = c("code", "year", "quint_type"))
data_depr <- left_join(data_depr, least_depr, by = c("code", "year", "quint_type"))

data_depr <- data_depr %>%  group_by(code, year, quint_type) %>%
  mutate(#calculating PAR. PAR of incomplete groups to NA
    #CI calculation missing, this can help https://onlinelibrary.wiley.com/doi/pdf/10.1002/sim.2779
    #https://fhop.ucsf.edu/sites/fhop.ucsf.edu/files/wysiwyg/pg_apxIIIB.pdf
    par_rr = (le/least_rate - 1) * proportion_pop,
    count= n(),
    par = case_when(count != 5 ~ NA_real_,
                    count == 5 ~ sum(par_rr)/(sum(par_rr) + 1) * 100),
    # Calculate ranges 
    abs_range = most_rate - least_rate,
    rel_range = most_rate / least_rate) %>% ungroup()

#Joining with totals.
#dataframe with the unique values for the different inequality measures
data_depr_match <- data_depr %>% 
  select(code, year, quint_type, sii, upci_sii, lowci_sii, rii, lowci_rii, upci_rii,
         rii_int, lowci_rii_int, upci_rii_int, par, abs_range, rel_range) %>% 
  unique()

data_depr_totals <- left_join(data_depr_totals, data_depr_match, 
                              by = c("code", "year", "quint_type"))

data_depr <- bind_rows(data_depr, data_depr_totals) 
















#Saving file
saveRDS(data_shiny, file = paste0(data_folder, "Shiny Data/", filename, "_ineq.rds"))